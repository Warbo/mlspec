{-# LANGUAGE OverloadedStrings #-}
module MLSpec.Theory where

import           Control.Monad
import           Data.Aeson
import           Data.Hashable
import           Data.List
import           Data.Maybe
import           Data.Stringable
import           Data.Typeable
import qualified Test.Arbitrary.Cabal   as Cabal
import           Test.Arbitrary.Haskell

newtype Package = P  String deriving (Eq, Ord)
newtype Module  = M  String deriving (Eq, Ord)
newtype Name    = N  String deriving (Eq, Ord)
newtype Type    = Ty String deriving (Eq, Ord)
newtype Arity   = A  Int    deriving (Eq, Ord)

unPkg  (P  x) = x
unMod  (M  x) = x
unName (N  x) = x
unType (Ty x) = x

newtype Entry = E (Package, Module, Name, Type, Arity) deriving (Show, Eq)

instance FromJSON Entry where
  parseJSON (Object o) = do
    p <- o .: "package"
    m <- o .: "module"
    n <- o .: "name"
    t <- o .: "type"
    a <- o .: "arity"
    return $ E (P p, M m, N n, Ty t, A a)
  parseJSON _ = mzero

instance ToJSON Entry where
  toJSON (E (P p, M m, N n, Ty t, A a)) = object [
      "package" .= p
    , "module"  .= m
    , "name"    .= n
    , "type"    .= t
    , "arity"   .= a
    ]

newtype Cluster = C [Entry] deriving (Eq)

instance FromJSON Cluster where
  parseJSON = fmap C . parseJSON

instance ToJSON Cluster where
  toJSON (C xs) = toJSON xs

type Symbol = (Module, Name, Type, Arity)

instance Show Package where
  show (P  x) = x

instance Show Module where
  show (M  x) = x

instance Show Name where
  show (N  x) = x

instance Show Type where
  show (Ty x) = x

instance Show Arity where
  show (A  x) = show x

data Theory = T [Package] [Module] [Symbol]

instance Show Theory where
  show t@(T pkgs mods syms) = show (pkgs, renderModule t)

getPackage :: Entry -> Package
getPackage (E (p, _, _, _, _)) = p

getMod :: Entry -> Module
getMod (E (_, m, _, _, _)) = m

getName :: Entry -> Name
getName (E (_, _, n, _, _)) = n

getType :: Entry -> Type
getType (E (_, _, _, t, _)) = t

getArity :: Entry -> Arity
getArity (E (_, _, _, _, a)) = a

theoryLine :: Symbol -> String
theoryLine (_, _, _, A a) | a > 5 = ""  -- QuickSpec only goes up to fun5
theoryLine (M m, N n, Ty t, a)    = concat [
    "\""
  , m
  , "."
  , n
  , "\" `Test.QuickSpec.fun"
  , show a
  , "` (("
  , m
  , "."
  , n
  , ") :: "
  , t
  , ")"
  ]

theory :: Cluster -> Theory
theory (C es) = T (nub pkgs) (nub mods) (nub symbols)
  where pkgs    = map getPackage  es
        mods    = map getMod      es
        symbols = [(m, n, t, a) | (E (_, m, n, t, a)) <- es]

mkCabal :: Theory -> Cabal.Project
mkCabal (T pkgs mods symbols) = Cabal.P {
    Cabal.name = "mlspec-temp" ++ show uid
  , Cabal.version = [1]
  , Cabal.headers = requiredHeaders
  , Cabal.sections = [
      Cabal.S "executable Main" [
          ("build-depends", intercalate ", " (map show deps))
        , ("main-is", "Main.hs")
        ]
    ]
  , Cabal.files = [
    (([], "Main.hs"), H (renderModule (T pkgs mods symbols)))
    ]
  }
  where deps = pkgs ++ requiredDeps
        uid  = abs (hash (map unPkg pkgs,
                          map unMod mods,
                          [(m, n, t, a) | (M m, N n, Ty t, A a) <- symbols]))

requiredDeps :: [Package]
requiredDeps = map P [
    "base >= 4.8 && < 4.9"
  , "quickspec < 2"
  ]

requiredHeaders = Cabal.S () [
    ("build-type",   "Simple")
  , ("category",     "Testing")
  , ("maintainer",   "nobody@example.com")
  , ("synopsis",     "Auto-generated by MLSpec")
  , ("description",  "Auto-generated by MLSpec")
  , ("license",      "PublicDomain")
  , ("cabal-version", ">= 1.2")
  ]

renderModule :: Theory -> String
renderModule (T pkgs mods symbols) = unlines [
    "module Main where"
  , renderImports mods
  , renderDef symbols
  , "main = Test.QuickSpec.quickSpec theory"
  ]

renderImports :: [Module] -> String
renderImports mods = unlines . map (("import qualified " ++) . show) $ allMods
  where allMods = mods ++ [M "Test.QuickSpec"]

renderDef :: [Symbol] -> String
renderDef symbols = concat [
    "theory = ["
  , intercalate ", " (map theoryLine symbols)
  , "]"
  ]

theoriesFromClusters :: [Cluster] -> [Theory]
theoriesFromClusters = map theory

getProjects s = let theories = theoriesFromClusters (readClusters s)
                 in map mkCabal theories

readClusters :: String -> [Cluster]
readClusters x = case decode . fromString $ x of
                      Nothing -> []
                      Just xs -> xs

writeTheoriesFromClusters :: FilePath -> String -> IO [FilePath]
writeTheoriesFromClusters dir s = mapM (Cabal.makeProject dir) (getProjects s)
