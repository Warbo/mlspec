module MLSpec.Theory where

import           Data.Hashable
import           Data.List
import           Data.Typeable
import qualified Test.Arbitrary.Cabal   as Cabal
import           Test.Arbitrary.Haskell

newtype Package = P  String deriving (Eq, Ord)
newtype Module  = M  String deriving (Eq, Ord)
newtype Name    = N  String deriving (Eq, Ord)
newtype Type    = Ty String deriving (Eq, Ord)

unPkg  (P x) = x
unMod  (M x) = x
unName (N x) = x

type Arity   = Int
type Symbol  = (Name, Arity, Type)

instance Show Package where
  show (P  x) = x

instance Show Module where
  show (M  x) = x

instance Show Name where
  show (N  x) = x

instance Show Type where
  show (Ty x) = x

data Theory = T [Package] [Module] [Symbol]

instance Show Theory where
  show t@(T pkgs mods syms) = show (pkgs, renderModule t)

getPackage :: String -> Package
getPackage = P . takeWhile (/= ':')

getMod :: String -> Module
getMod x = let (N n, _) = getNameType x
            in M . init . dropWhileEnd (/= '.') $ n

getNameType :: String -> (Name, Type)
getNameType s = (N name, Ty typ)
  where suffix = tail . dropWhile (/= ':') $ s
        name   = takeWhile (/= ':') suffix
        typ    = filter (/= '"') $ tail (dropWhile (/= ':') suffix)

arity :: Type -> Int
arity (Ty t) = bits t - 1
  where bits :: String -> Int
        bits ('-':'>':s) = 1 + bits s
        bits (c:s)       = bits s
        bits []          = 1

theoryLine :: Symbol -> String
theoryLine (_, a, _) | a > 5 = ""  -- QuickSpec only goes up to fun5
theoryLine (N n, a, Ty t)    = concat [
    "\""
  , n
  , "\" `Test.QuickSpec.fun"
  , show a
  , "` (("
  , n
  , ") :: "
  , t
  , ")"
  ]

tabWords :: String -> [String]
tabWords s = let (pre, post) = span (/= '\t') s
             in case pre of
                     [] -> []
                     _  -> pre : (case post of
                                       ""     -> []
                                       '\t':s -> tabWords s)

theory :: String -> Theory
theory l = T (nub pkgs) (nub mods) (nub symbols)
  where bits = tabWords l
        pkgs = map getPackage  bits
        nts  = map getNameType bits
        mods = map getMod      bits
        symbols = [(n, arity t, t) | (n,t) <- nts]

mkCabal :: Theory -> Cabal.Project
mkCabal (T pkgs mods symbols) = Cabal.P {
    Cabal.name = "mlspec-temp" ++ show uid
  , Cabal.version = [1]
  , Cabal.headers = requiredHeaders
  , Cabal.sections = [
      Cabal.S "executable Main" [
          ("build-depends", intercalate ", " (map show deps))
        , ("main-is", "Main.hs")
        ]
    ]
  , Cabal.files = [
    (([], "Main.hs"), H (renderModule (T pkgs mods symbols)))
    ]
  }
  where deps = pkgs ++ requiredDeps
        uid  = abs (hash (map unPkg pkgs,
                          map unMod mods,
                          map (\((N x), y, (Ty z)) -> (x, y, z)) symbols))

requiredDeps :: [Package]
requiredDeps = map P [
    "base >= 4.8 && < 4.9"
  , "quickspec < 2"
  ]

requiredHeaders = Cabal.S () [
    ("build-type",   "Simple")
  , ("category",     "Testing")
  , ("maintainer",   "nobody@example.com")
  , ("synopsis",     "Auto-generated by MLSpec")
  , ("description",  "Auto-generated by MLSpec")
  , ("license",      "PublicDomain")
  , ("cabal-version", ">= 1.2")
  ]

renderModule :: Theory -> String
renderModule (T pkgs mods symbols) = unlines [
    "module Main where"
  , renderImports mods
  , renderDef symbols
  , "main = Test.QuickSpec.quickSpec theory"
  ]

renderImports :: [Module] -> String
renderImports mods = unlines . map (("import qualified " ++) . show) $ allMods
  where allMods = mods ++ [M "Test.QuickSpec"]

renderDef :: [Symbol] -> String
renderDef symbols = concat [
    "theory = ["
  , intercalate ", " (map theoryLine symbols)
  , "]"
  ]

theoriesFromClusters :: String -> [Theory]
theoriesFromClusters = map theory . lines

writeTheoriesFromClusters :: FilePath -> String -> IO [FilePath]
writeTheoriesFromClusters dir s = do
    mapM (Cabal.makeProject dir) projects
  where theories = theoriesFromClusters s
        projects = map mkCabal theories
